## select的使用总结

+ select不会自动取消掉无效的套接字

  > 虽然 epoll 会自动取消掉被关闭的套接字，但是select并不会。如果不及时去掉的话，会出现10038错误，告诉你对一个不是套接字的对象做了套接字的操作

+ select的列表参数每次都需要重新赋值

  > 我一直以为是类似于epoll那样，把总的列表赋值给他就行了。结果他会直接修改参数，导致select一次之后有些被放弃监听了。所以需要自己维护一个所有套接字的集合

+ select只能轮询64个套接字

  > 本来我以为作为客户端的话已经够用了，结果没想到还是不够啊，打开几个网页之后就超过了64个。于是修改了上限到1024，不过感觉工作的不是很畅快。
  >
  > 因为是单线程的问题，所以没有锁的问题。也不应该是卡在哪里了，不太明白是为什么卡住了。不过太多的控制台输出也确实会影响效率
  >
  > 如果是因为性能卡顿的话，也许后面是用到线程池呢。。。虽然开发了线程池，但是一直没用。。。完全想不到这个应用哪里会需要线程池。好像只是一些简单的字符串处理。




## Tips

+ 迭代器的使用

  > 虽然这个不算是select的内容，但是一般select会和map一起使用。在清理的时候需要注意迭代器失效的问题。比如这次就在注册的回调函数中取消注册了map中的元素导致迭代器失效出错了。不过最后换了写法就没有这个问题了
  >
  > 另外，如果是想要删除所有元素的话，直接使用clear是个好的选择，不用担心迭代器失效的问题。如果需要在ereas之前做什么工作的话，那就对每个元素先做完，再clear

+ 延时删除的使用

  > 如果在一个循环中调用了对象中的方法，而这个方法中的某种行为会导致后面的循环变量出现问题，那么就可以通过在对象中设计一个删除标志的方式实现延迟删除。这样就不会出现删除了后面的对象导致后面的循环出错的情况。
  
+ 如果在头文件中使用了`static`的成员变量，那么一定要记得在`cpp`中定义以申请内存，否则将会出现找不到符号的问题。

+ 如果一个类中的成员是静态的，并且写的代码是多线程程序，那么一定记得考虑是不是安全的。

+ 对于非法连接的问题

  > 如果有人，与服务器建立很多很多的连接，但是什么数据都不发送，是否会导致占用内存过多？又或者对于现在的状况，如果只发送一个字节(数据包头是`2`字节)，服务端将会卡在`RecvN()`函数的位置。导致出现拒绝服务攻击。那就需要谨慎使用`RecvN()`函数
  
+ 一开始设计一个类的时候就需要考虑到他的生命周期，还有出现异常之后的内存回收问题。否则设计出来的类都是不干净的类，当程序想要结束的时候并不能保证所有的内存都回归了。虽然在进程结束之后操作系统会回收进程所有的内存，但是如果想要实现重启这样的工作，是否就会比较容易出现问题呢？而且如果对于每一个类的生命周期不清楚的话，很容易出现内存泄漏的问题。

+ 如果一个类在代码块结束后就没用了，那么就应该使用局部变量而不是`new`，因为前者在栈上面，出了作用域就自己释放了。如果需要其中的内容持久化保存，那么处理其中数据的方法或者类还是自己保留一份比较好。如果一定要`new` 那么，看清楚函数中`return`的时候是否`delete`了。

+ 对于`epoll`是否还需要通过`map`记录所有的对象？

  实际上一开始考虑的事情就是怕程序结束之后还有对象没有被顺利的释放掉，所以可能需要在`poll`循环结束的时候主动释放所有的对象。但是从程序设计的角度来说，并不需要去考虑这个问题，`epoll`本身就能够作为一种管理器。实际上如果对于各个对象的生命周期进行合理的设计，并不需要额外的功夫去保存`epoll`的对象。

+ 看起来还是需要的

  实际情况比想象中的复杂，分为两种情况。

  首先是正常运行的时候，如果在`OnClose()`中直接`delete`了别的对象，如果此时这个对象正好在`epoll`队列里面，那么在调用他的时候就会出现问题，所以需要延时删除。

  其次是整个程序需要退出的时候，应该直接`delete`，因为`poll`循环已经结束了。所以，没有机会去`delete`。

  所以，综上所述，对对象的生命周期管理看起来一定要由`poll`来结束。那么同时也意味着需要使用额外的`map`管理所有的对象。

+ 可以直接`delete`

  如果决定要直接`delete`的话，就需要解决上面提到的问题。实际上，如果保证每个对象在`delete`的时候都能在`poll`中反向注册一下，那么完全可以把删除掉的对象记录在一个`map`中，每次`poll`循环结束的时候都清空。如果能够保证这个严格实施的话，就可以不用在`poll`中记录所有对象了，毕竟在`SereverListener`和`ClientHandle`这样的对象中都记录了。
  
  说起来客户端好像一直都是直接删除对象，，，这个是导致出现接受结束bug的原因吗？并不是，因为客户端在取消注册之后，就把对象从那个`map`中删除掉了，所以根本不可能遇到那个对象。但是奇怪的是，下断点的时候能看到被取消注册的对象，，，
  
  





## 粘包问题

> 是的，按照标准的解决方法，`TCP`是没有粘包问题的，但是解决方式该是什么样子的呢？
>
> 比较常用的方法就是给数据添加一个数据包头。



+ 比较极端的情况下，`recv`函数可能读取`1`字节就返回了这样数据包的头甚至都没有接受完，所以一定要封装一个`RecvN(char* data, int len)`函数，含义是必须接收`len`长度的数据才会返回。接受完包头之后一定要使用`recv()`函数接收剩下的数据，因为`RecvN()`效率可能会比较低。比如极端情况下可能会出现发了包头的一半，剩下的不发了。那么就会一直阻塞在`RecvN()`函数中。

