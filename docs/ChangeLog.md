> 最终还是觉得`log`写在`Readme`里面太多了，所以决定搬到这里来

# Log

+ 当客户端主动断开的时候，服务端会崩溃

  > 原因是对`Recv`的返回值预计错误，以为recv返回0就表示对端断开。如果对端close()这里返回0，如果直接关闭进程，返回-1

+ 如果给select函数第三个参数设置超时时间会有`10022`错误

+ 客户端Packet类中取包长多了2

  > `packet.h`里面传入的`data_len`的结果就是包含`sid`的包长度，所以不需要加上`HEADER_SIZE`

+ 到来的请求会导致客户端关闭

  > 通过添加 getchar()看到了控制台的输出，是select出现了 10038错误，翻译过来就是对不是套接字的变量执行了套接字操作。这个一般是套接字被关闭了，但是依旧操作导致的。所以着重检查哪里被关闭了。
  >
  > 最终在检查Poll注册的时候发现，_handle_http没有被取消注册。这就导致 http服务器与客户端断开连接的时候，关闭套接字，但是select的监听队列中还在。所以在关闭套接字的地方取消注册就好了。另外，取消注册会导致\_readfd_map结构的改变，所以每次需要考虑erase之后迭代器失效的问题。

+ 尝试实现Https的处理，客户端好像不会响应

  > 忘记看是谁先断开的了

+ sid会变成52685

  > 出现了好几次，然后突然想起来，这个值是不是一个很特殊的值。突然明白了什么，十六进制的cdcd，似乎是个比较特殊的值，然后去查了一下["烫烫烫屯屯屯" 那些事 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27253604)
  >
  > 明白了这是没有被初始化的堆内存，那么问题就只能是在收包函数里面了。但是怎么验证呢？

+ 对于上面的问题，原因是因为

  > 我为了省事儿，每次`OnRecv()`的时候都会新`new`缓冲区，结束的时候`free`掉，这时候会有一个问题。
  >
  > 接收头部的时候，申请一个，接收另一段的时候是新的内存。如果一个包被分成了三段。那么最后一段就是在一个全新的缓冲区的尾部，头部当然就是`cdcd`了。前面几个请求没有出问题可能是脸白，也就是没有出现三段包。
  >
  > 不能偷懒啊 啊啊啊

+ 当运行一段时间之后(大约400个session)会出现异常的包头大小

  > 会突然出现一个包头大小超过预定大小的包头
  >
  > 目前来看，可能是因为读取的顺序被破坏了。或者根本就是发送的顺序有错。是否考虑对每个会话都使用独立的缓冲区。
  >
  > 如果公用缓冲区的话，会不会出现接收混乱的问题？
  >
  > 也就是，A包长度50，B包长度60。A先接受了30，然后结果开始接收B的头？这个应该不会，发送方应该会保证以Send的顺序发送吧。也就是不应该出现一个包中混杂别的包的情况。理由是每次出现这样的问题时，pos的值都是0，也就是说并没有前一个包。
  >
  > 绝对保证包确实接收完了，最终ret的和等于预计包大小

+ 对于上面的问题，终于找到了原因

  > 是因为没有考虑接收包头的时候返回值为1的情况，算是一个比较极端的情况。如果返回值是1，那么这个包头的大小就不正确了。比如这次是零，那么下次再调用`RecvPacket`的时候，肯定就错位了，所以会得到一个很大的`len`，所以这次的话，接受包头使用`RecvN()`函数来做，保证一定会接收到包头。而且是完整的，当然这个实现方案的性能估计不会很好。

+ 添加了`AddressSanitizer`

  > 发现了两个问题了已经，首先就是`BaseNet`的析构函数不是虚函数，导致子类的析构函数没有被调用，导致内存没有完全释放。其次就是`RequestHandle`对象，被释放了之后，可能会被`poll`调用到
  >
  > 具体来看，就是接收到了客户端消息，需要清理掉`session`，清理完毕之后没有从`poll`中删除，导致被调用到了。所以，对于各个对象的生命周期还是需要好好理清楚的。其次，发现`gdb`下条件断点比`assert`好用...

+ 在`poll`的循环中执行`OnRecv()`的时候，里面可能会有释放`poll`池中对象的情况

  > 导致的情况就是会出现内存非法使用。如果不是开启`ASan`，我其实也不会注意到这个问题。现在的解决办法就是通过在`BaseNet`中添加一个`delete`的标志位，需要删除的时候只是设置标志位。最终删除的时候是在`poll`里面删除。这样可以避免非法使用内存的问题。实际上这个问题还是比较重要的，比如说公司项目里面`session`和`filter`的设计，都是使用了延时删除的设计。