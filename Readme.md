# 还是这个名字 :)
# 目录介绍
## common
里面是客户端和服务端会共同需要的代码，这样就不用同时维护两份代码了。当然，编写的时候也需要考虑两个平台兼容的问题了。

## poll
简单实现的一个网络库，只有几百行代码，也不知道能不能称之为`库`，通过宏定义区别客户端和服务端的部分。因为服务端使用`epoll`模型，但是`windows`没有这个模型。那么客户端目前选择`select`，因为对于客户端来说似乎请求数量并不会很大。再者`epoll`和`select`结构上比较相似，比较容易使用宏区分。

## thread
是一个简单的线程池，不过这次好像用不到线程池。另外`fetch`任务的地方其实有个`bug`，不过不影响其正常工作。

## client
是客户端了，使用`vs`开发，建立工程。将来也许会考虑同时支持`linux`，也就是`client`文件夹下有`sln`通过`vs`直接能够编译，同时也有`Makefile`通过`Linux`直接`make`就能出二进制文件。不过服务端目前没有考虑兼容`windows`，因为我也没有`windows`服务器。不过如果只是通过简单的修改就能兼容`windows`的话，也未尝不可。最后才会去做这个事情。

## server
服务端，直接`make`就能得到二进制文件。未来会介绍一下其工作原理，但是现在还没有开发完成。

# Todo
+ ~~完成目录调整~~
+ ~~跑通客户端~~
+ ~~加上启动参数 指定主机和端口~~
+ 好像客户端指针出现了异常，导致发出了错误的包，而且好像还很严重。dump出来的是二进制数据，是个线索
+ 客户端密码认证
+ 代理列表获取
+ 管理输出的日志



## select的使用总结

+ select不会自动取消掉无效的套接字

  > 虽然 epoll 会自动取消掉被关闭的套接字，但是select并不会。如果不及时去掉的话，会出现10038错误，告诉你对一个不是套接字的对象做了套接字的操作

+ select的列表参数每次都需要重新赋值

  > 我一直以为是类似于epoll那样，把总的列表赋值给他就行了。结果他会直接修改参数，导致select一次之后有些被放弃监听了。所以需要自己维护一个所有套接字的集合

+ select只能轮询64个套接字

  > 本来我以为作为客户端的话已经够用了，结果没想到还是不够啊，打开几个网页之后就超过了64个。于是修改了上限到1024，不过感觉工作的不是很畅快。
  >
  > 因为是单线程的问题，所以没有锁的问题。也不应该是卡在哪里了，不太明白是为什么卡住了。不过太多的控制台输出也确实会影响效率
  >
  > 如果是因为性能卡顿的话，也许后面是用到线程池呢。。。虽然开发了线程池，但是一直没用。。。完全想不到这个应用哪里会需要线程池。好像只是一些简单的字符串处理。

+ 迭代器的使用

  > 虽然这个不算是select的内容，但是一般select会和map一起使用。在清理的时候需要注意迭代器失效的问题。比如这次就在注册的回调函数中取消注册了map中的元素导致迭代器失效出错了。不过最后换了写法就没有这个问题了
  >
  > 另外，如果是想要删除所有元素的话，直接使用clear是个好的选择，不用担心迭代器失效的问题。如果需要在ereas之前做什么工作的话，那就对每个元素先做完，再clear

# Log
+ 当客户端主动断开的时候，服务端会崩溃
  
    > 原因是对`Recv`的返回值预计错误，以为recv返回0就表示对端断开。如果对端close()这里返回0，如果直接关闭进程，返回-1
    
+ 如果给select函数第三个参数设置超时时间会有`10022`错误

+ 客户端Packet类中取包长多了2
  
    > `packet.h`里面传入的`data_len`的结果就是包含`sid`的包长度，所以不需要加上`HEADER_SIZE`
    
+ 到来的请求会导致客户端关闭

    > 通过添加 getchar()看到了控制台的输出，是select出现了 10038错误，翻译过来就是对不是套接字的变量执行了套接字操作。这个一般是套接字被关闭了，但是依旧操作导致的。所以着重检查哪里被关闭了。
    >
    > 最终在检查Poll注册的时候发现，_handle_http没有被取消注册。这就导致 http服务器与客户端断开连接的时候，关闭套接字，但是select的监听队列中还在。所以在关闭套接字的地方取消注册就好了。另外，取消注册会导致\_readfd_map结构的改变，所以每次需要考虑erase之后迭代器失效的问题。
    
+ 尝试实现Https的处理，客户端好像不会响应

    > 忘记看是谁先断开的了
