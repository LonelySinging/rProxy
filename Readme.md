# 还是这个名字 :)
# 目录介绍
## common
里面是客户端和服务端会共同需要的代码，这样就不用同时维护两份代码了。当然，编写的时候也需要考虑两个平台兼容的问题了。

## poll
简单实现的一个网络库，只有几百行代码，也不知道能不能称之为`库`，通过宏定义区别客户端和服务端的部分。因为服务端使用`epoll`模型，但是`windows`没有这个模型。那么客户端目前选择`select`，因为对于客户端来说似乎请求数量并不会很大。再者`epoll`和`select`结构上比较相似，比较容易使用宏区分。

## thread
是一个简单的线程池，不过这次好像用不到线程池。另外`fetch`任务的地方其实有个`bug`，不过不影响其正常工作。

## client
是客户端了，使用`vs`开发，建立工程。将来也许会考虑同时支持`linux`，也就是`client`文件夹下有`sln`通过`vs`直接能够编译，同时也有`Makefile`通过`Linux`直接`make`就能出二进制文件。不过服务端目前没有考虑兼容`windows`，因为我也没有`windows`服务器。不过如果只是通过简单的修改就能兼容`windows`的话，也未尝不可。最后才会去做这个事情。

## server
服务端，直接`make`就能得到二进制文件。未来会介绍一下其工作原理，但是现在还没有开发完成。

# Todo
+ ~~完成目录调整~~
+ ~~跑通客户端~~
+ ~~加上启动参数 指定主机和端口~~
+ 好像客户端指针出现了异常，导致发出了错误的包，而且好像还很严重。dump出来的是二进制数据，是个线索
+ `conf`的开发
+ 客户端密码认证
+ 代理列表获取
+ 管理输出的日志



## select的使用总结

+ select不会自动取消掉无效的套接字

  > 虽然 epoll 会自动取消掉被关闭的套接字，但是select并不会。如果不及时去掉的话，会出现10038错误，告诉你对一个不是套接字的对象做了套接字的操作

+ select的列表参数每次都需要重新赋值

  > 我一直以为是类似于epoll那样，把总的列表赋值给他就行了。结果他会直接修改参数，导致select一次之后有些被放弃监听了。所以需要自己维护一个所有套接字的集合

+ select只能轮询64个套接字

  > 本来我以为作为客户端的话已经够用了，结果没想到还是不够啊，打开几个网页之后就超过了64个。于是修改了上限到1024，不过感觉工作的不是很畅快。
  >
  > 因为是单线程的问题，所以没有锁的问题。也不应该是卡在哪里了，不太明白是为什么卡住了。不过太多的控制台输出也确实会影响效率
  >
  > 如果是因为性能卡顿的话，也许后面是用到线程池呢。。。虽然开发了线程池，但是一直没用。。。完全想不到这个应用哪里会需要线程池。好像只是一些简单的字符串处理。

+ 迭代器的使用

  > 虽然这个不算是select的内容，但是一般select会和map一起使用。在清理的时候需要注意迭代器失效的问题。比如这次就在注册的回调函数中取消注册了map中的元素导致迭代器失效出错了。不过最后换了写法就没有这个问题了
  >
  > 另外，如果是想要删除所有元素的话，直接使用clear是个好的选择，不用担心迭代器失效的问题。如果需要在ereas之前做什么工作的话，那就对每个元素先做完，再clear

# Log
+ 当客户端主动断开的时候，服务端会崩溃
  
    > 原因是对`Recv`的返回值预计错误，以为recv返回0就表示对端断开。如果对端close()这里返回0，如果直接关闭进程，返回-1
    
+ 如果给select函数第三个参数设置超时时间会有`10022`错误

+ 客户端Packet类中取包长多了2
  
    > `packet.h`里面传入的`data_len`的结果就是包含`sid`的包长度，所以不需要加上`HEADER_SIZE`
    
+ 到来的请求会导致客户端关闭

    > 通过添加 getchar()看到了控制台的输出，是select出现了 10038错误，翻译过来就是对不是套接字的变量执行了套接字操作。这个一般是套接字被关闭了，但是依旧操作导致的。所以着重检查哪里被关闭了。
    >
    > 最终在检查Poll注册的时候发现，_handle_http没有被取消注册。这就导致 http服务器与客户端断开连接的时候，关闭套接字，但是select的监听队列中还在。所以在关闭套接字的地方取消注册就好了。另外，取消注册会导致\_readfd_map结构的改变，所以每次需要考虑erase之后迭代器失效的问题。
    
+ 尝试实现Https的处理，客户端好像不会响应

    > 忘记看是谁先断开的了
    
+ sid会变成52685

    > 出现了好几次，然后突然想起来，这个值是不是一个很特殊的值。于是打开计算器，![image-20210807134110067](.\Readme.assets\image-20210807134110067.png)
    >
    > 突然明白了什么，十六进制的cdcd，似乎是个比较特殊的值，然后去查了一下["烫烫烫屯屯屯" 那些事 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27253604)
    >
    > 明白了这是没有被初始化的堆内存，那么问题就只能是在收包函数里面了。但是怎么验证呢？

+ 对于上面的问题，原因是因为

    > 我为了省事儿，每次`OnRecv()`的时候都会新`new`缓冲区，结束的时候`free`掉，这时候会有一个问题。
    >
    > 接收头部的时候，申请一个，接收另一段的时候是新的内存。如果一个包被分成了三段。那么最后一段就是在一个全新的缓冲区的尾部，头部当然就是`cdcd`了。前面几个请求没有出问题可能是脸白，也就是没有出现三段包。
    >
    > 不能偷懒啊 啊啊啊
    
+ 当运行一段时间之后(大约400个session)会出现异常的包头大小

    > 会突然出现一个包头大小超过预定大小的包头
    >
    > 目前来看，可能是因为读取的顺序被破坏了。或者根本就是发送的顺序有错。是否考虑对每个会话都使用独立的缓冲区。
    >
    > 如果公用缓冲区的话，会不会出现接收混乱的问题？
    >
    > 也就是，A包长度50，B包长度60。A先接受了30，然后结果开始接收B的头？这个应该不会，发送方应该会保证以Send的顺序发送吧。也就是不应该出现一个包中混杂别的包的情况。理由是每次出现这样的问题时，pos的值都是0，也就是说并没有前一个包。
    >
    > 绝对保证包确实接收完了，最终ret的和等于预计包大小
    
+ 对于上面的问题，终于找到了原因

    > 是因为没有考虑接收包头的时候返回值为1的情况，算是一个比较极端的情况。如果返回值是1，那么这个包头的大小就不正确了。比如这次是零，那么下次再调用`RecvPacket`的时候，肯定就错位了，所以会得到一个很大的`len`，所以这次的话，接受包头使用`RecvN()`函数来做，保证一定会接收到包头。而且是完整的，当然这个实现方案的性能估计不会很好。

+ 添加了`AddressSanitizer`

    > 发现了两个问题了已经，首先就是`BaseNet`的析构函数不是虚函数，导致子类的析构函数没有被调用，导致内存没有完全释放。其次就是`RequestHandle`对象，被释放了之后，可能会被`poll`调用到
    >
    > 具体来看，就是接收到了客户端消息，需要清理掉`session`，清理完毕之后没有从`poll`中删除，导致被调用到了。所以，对于各个对象的生命周期还是需要好好理清楚的。其次，发现`gdb`下条件断点比`assert`好用...

